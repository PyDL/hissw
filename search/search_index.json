{
    "docs": [
        {
            "location": "/",
            "text": "hiss(w)\n\n\nThe \nSolarSoftware\n (SSW) stack contains nearly every piece of software a solar physicist needs. While libraries like \nAstropy\n, \nSunPy\n, and \nChiantiPy\n provide Python equivalents to many of these IDL packages, there's still a lot of functionality only available in SSW and not enough hours in the day to rewrite it all in Python.\n\n\nhissw\n (pronounced hiss \nor\n hiss-SSW) is a lightweight package that allows you to write IDL scripts (either inline or in a separate file) which use your installed SSW packages and return the results to your local Python namespace. hissw uses Jinja2 templates to generate SSW startup scripts and then runs your IDL code in the background. You can also use Jinja syntax to inject arguments from Python into IDL. The results are then saved to a file and then loaded back in using the amazing \nreadsav()\n function in \nscipy.io\n.\n\n\nInstall and Configuration\n\n\nInstall the dependencies with \nconda\n (preferred) or \npip\n,\n\n\n$ conda install jinja2 scipy\n\n\n\n\n\nand then install this package from GitHub via \npip\n,\n\n\n$ pip install git+git://github.com/wtbarnes/hissw.git\n\n\n\n\n\nAlternatively, you can download and install the source yourself,\n\n\n$ git clone https://github.com/wtbarnes/hissw.git\n$ \ncd\n hissw\n$ python setup.py install\n\n\n\n\n\nLastly, you can set the locations of your IDL and SSW installs in a configuration file located in \n$HOME/.hissw/hisswrc\n,\n\n\n[hissw]\n\n\nssw_home\n=\n/path/to/ssw/tree\n\n\nidl_home\n=\n/path/to/local/idl/install\n\n\n\n\n\n\nBridging the IDL-Python Gap the Bad Way...\n\n\nWord(s) of Caution\n\n\n\n\nUnfortunately, a local install of of IDL \nand\n SSW is required\n\n\nRelies on executing shell commands with the \nsubprocess\n module. As such, only Unix-like platforms (e.g. Linux, macOS) are supported\n\n\nWidgets and plotting will not work\n\n\nThis has \nnot\n been tested extensively against all SSW/IDL functionality. There are likely many cases where hissw will not work. \nBug reports\n and \npull requests\n welcome!",
            "title": "Getting Started"
        },
        {
            "location": "/#hissw",
            "text": "The  SolarSoftware  (SSW) stack contains nearly every piece of software a solar physicist needs. While libraries like  Astropy ,  SunPy , and  ChiantiPy  provide Python equivalents to many of these IDL packages, there's still a lot of functionality only available in SSW and not enough hours in the day to rewrite it all in Python.  hissw  (pronounced hiss  or  hiss-SSW) is a lightweight package that allows you to write IDL scripts (either inline or in a separate file) which use your installed SSW packages and return the results to your local Python namespace. hissw uses Jinja2 templates to generate SSW startup scripts and then runs your IDL code in the background. You can also use Jinja syntax to inject arguments from Python into IDL. The results are then saved to a file and then loaded back in using the amazing  readsav()  function in  scipy.io .",
            "title": "hiss(w)"
        },
        {
            "location": "/#install-and-configuration",
            "text": "Install the dependencies with  conda  (preferred) or  pip ,  $ conda install jinja2 scipy  and then install this package from GitHub via  pip ,  $ pip install git+git://github.com/wtbarnes/hissw.git  Alternatively, you can download and install the source yourself,  $ git clone https://github.com/wtbarnes/hissw.git\n$  cd  hissw\n$ python setup.py install  Lastly, you can set the locations of your IDL and SSW installs in a configuration file located in  $HOME/.hissw/hisswrc ,  [hissw]  ssw_home = /path/to/ssw/tree  idl_home = /path/to/local/idl/install",
            "title": "Install and Configuration"
        },
        {
            "location": "/#bridging-the-idl-python-gap-the-bad-way",
            "text": "",
            "title": "Bridging the IDL-Python Gap the Bad Way..."
        },
        {
            "location": "/#words-of-caution",
            "text": "Unfortunately, a local install of of IDL  and  SSW is required  Relies on executing shell commands with the  subprocess  module. As such, only Unix-like platforms (e.g. Linux, macOS) are supported  Widgets and plotting will not work  This has  not  been tested extensively against all SSW/IDL functionality. There are likely many cases where hissw will not work.  Bug reports  and  pull requests  welcome!",
            "title": "Word(s) of Caution"
        },
        {
            "location": "/examples/simple_example/",
            "text": "First, let's look at a few plain IDL examples, no SSW needed. In the simplest case, we can return some quantity generated by IDL (no inputs required) and return it to our Python session. This example comes from \nCoyote's Guide to IDL Programming\n.\n\n\nimport\n \nhissw\n\n\nimport\n \nmatplotlib.pyplot\n \nas\n \nplt\n\n\nscript\n \n=\n \n'''\n\n\nn = 5\n\n\ni = REBIN(LINDGEN(n), n, n)           \n\n\nj = REBIN(TRANSPOSE(LINDGEN(n)), n, n)\n\n\nmask = (i GE j)\n\n\n'''\n\n\nssw\n \n=\n \nhissw\n.\nScriptMaker\n()\n\n\nresults\n \n=\n \nssw\n.\nrun\n(\nscript\n)\n\n\nplt\n.\nimshow\n(\nresults\n[\n'mask'\n])\n\n\n\n\n\n\nThis should generate a plot that looks something like this,\n\n\n\nBut what if we want to input the size of our upper triangular array with Python? We can use \nJinja templating syntax\n in our IDL script and then pass in an argument for \nn\n,\n\n\nscript\n \n=\n \n'''\n\n\nn = {{ n }}\n\n\ni = REBIN(LINDGEN(n), n, n)           \n\n\nj = REBIN(TRANSPOSE(LINDGEN(n)), n, n)\n\n\nmask = (i GE j)\n\n\n'''\n\n\nresults\n \n=\n \nssw\n.\nrun\n(\nscript\n,\n \nargs\n=\n{\n'n'\n:\n \n100\n})\n\n\nplt\n.\nimshow\n(\nresults\n[\n'mask'\n])",
            "title": "Simple Example"
        },
        {
            "location": "/examples/aia_example/",
            "text": "The temperature response functions of the EUV channels of the Atmospheric Imaging Assembly (AIA) are used to understand the temperature of the plasma observed by the different telescopes on the instrument. \n\n\nWhile these are difficult to calculate, SSW provides a single simple routine to calculate them. The script below shows how you can easily calculate them using hissw and return the results to your current Python workspace and plot them with Matplotlib.\n\n\nimport\n \nnumpy\n \nas\n \nnp\n\n\nimport\n \nmatplotlib.pyplot\n \nas\n \nplt\n\n\nimport\n \nhissw\n\n\nscript\n \n=\n \n\"\"\"\n\n\nresponse = aia_get_response(/{{ flags | join(',/') }})\n\n\n; Pull needed elements out of structure\n\n\nlogt = response.logte\n\n\nresp94 = response.a94.tresp\n\n\nresp131 = response.a131.tresp\n\n\nresp171 = response.a171.tresp\n\n\nresp193 = response.a193.tresp\n\n\nresp211 = response.a211.tresp\n\n\nresp335 = response.a335.tresp\n\n\n; Interpolate\n\n\ninterp_logt = {{ interp_logt }}\n\n\ninterp_resp94 = interpol(resp94,logte,interp_logte)\n\n\ninterp_resp131 = interpol(resp131,logte,interp_logte)\n\n\ninterp_resp171 = interpol(resp171,logte,interp_logte)\n\n\ninterp_resp193 = interpol(resp193,logte,interp_logte)\n\n\ninterp_resp211 = interpol(resp211,logte,interp_logte)\n\n\ninterp_resp335 = interpol(resp335,logte,interp_logte)\n\n\n\"\"\"\n\n\ninterp_logt\n \n=\n \nnp\n.\nlinspace\n(\n5\n,\n8\n,\n1000\n)\n\n\nflags\n \n=\n \n[\n'temp'\n,\n'dn'\n,\n'timedepend_date'\n,\n'evenorm'\n]\n\n\nssw\n \n=\n \nhissw\n.\nScriptMaker\n(\nssw_packages\n=\n[\n'sdo/aia'\n],\n \nssw_paths\n=\n[\n'aia'\n])\n\n\ninputs\n \n=\n \n{\n'flags'\n:\n \nflags\n,\n \n'interp_logt'\n:\n \ninterp_logt\n.\ntolist\n()}\n\n\nssw_resp\n \n=\n \nssw\n.\nrun\n(\nscript\n,\n \nargs\n=\ninputs\n)\n\n\n# Plotting\n\n\nt\n \n=\n \n10.\n**\nssw_resp\n[\n'logte'\n]\n\n\ninterp_t\n \n=\n \n10.\n**\ninterp_logte\n\n\nfor\n \ni\n,\nchannel\n \nin\n \nenumerate\n([\n94\n,\n131\n,\n171\n,\n193\n,\n211\n,\n335\n]):\n\n    \nplt\n.\nplot\n(\nt\n,\n \nssw_resp\n[\nf\n'resp{channel}'\n],\n \n'o'\n,\n \ncolor\n=\nf\n'C{i}'\n,\n \nmarkevery\n=\n3\n)\n\n    \nplt\n.\nplot\n(\ninterp_t\n,\n \nssw_resp\n[\nf\n'interp_resp{channel}'\n],\n \n'-'\n,\n \ncolor\n=\nf\n'C{i}'\n,\n \nlabel\n=\nf\n'{channel}'\n)\n\n\nplt\n.\nxlabel\n(\nr\n'$T$ [K]'\n)\n\n\nplt\n.\nylabel\n(\n'Response'\n)\n\n\nplt\n.\nxscale\n(\n'log'\n)\n\n\nplt\n.\nyscale\n(\n'log'\n)\n\n\nplt\n.\nylim\n(\n1e-30\n,\n3e-24\n)\n\n\nplt\n.\nlegend\n()\n\n\nplt\n.\nshow\n()",
            "title": "AIA Response Functions"
        },
        {
            "location": "/examples/chianti_example/",
            "text": "",
            "title": "Continuum Emission with CHIANTI"
        },
        {
            "location": "/examples/demreg_example/",
            "text": "",
            "title": "Differential Emission Measure"
        }
    ]
}